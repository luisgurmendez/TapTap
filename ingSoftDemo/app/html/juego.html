<!DOCTYPE html>
<link rel="stylesheet" href="bootstrap.min.css">

<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Demo</title>
</head>
<body>
<h1 align="center">Demo</h1>
<hr class="styled">
<div>
  <span>00:<span id="timer">0</span> s</span>
</div>
<table style="margin:0 auto;" id="board">
</table>



</body>
</html>

<style>

  div{
    text-align: center;
  }

  span{
    font-size: 50px;
  }

  hr.styled{
    border: 0;
    height: 1px;
    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
  }

  h1{
    font-size: 70px;
    color: #8190ff;
    margin:0 auto;
  }

  .point{
    height: 90px;
    width: 90px;
    border-style: solid;
    border-width: 0px;
    border-color: transparent;
  }

  .point > div{
    background: #bbbbbb;
    height: 95%;
    width: 95%;
    border-radius: 50%;
  }

  @media screen and (max-width: 480px) {
    .point{
      height: 70px;
      width: 70px;
    }

    h1{
      font-size: 40px;
    }

    span{
      font-size: 20px;
    }
  }


</style>
<script src="jquery-2.2.2.js"></script>
<script src="jquery.mobile-1.4.5.js"></script>
<script>



  var wsUri = "ws://localhost:8080/Game/gameWS";

  var websocket;
  var user_id;
  var self_color;
  var opponent_color;
  var can_play=false
  colors={'Red':'#fb5041','Blue':"#1968ff",'#fb5041':'#fb5041',"#1968ff":"#1968ff"}
  reverse_colors={'#fb5041':'#1968ff',"#1968ff":"#fb5041"}

  function setColor(color){
    self_color = colors[color];
    opponent_color = reverse_colors[self_color];
  }

  // Populate table with point DOMs
  function generateBoard(size){

    var tableHTML=""

    for (i=0; i<size; i++ ){
      tableHTML +="<tr>"
      for (j=0; j<size;j++){
        tableHTML +="<td data-x='" + j + "' data-y='" + i + "'>" + pointHTML + "</td>"
      }
      tableHTML +="</tr>"
    }
    board.append(tableHTML)
  }

  function startGame(time,matrixSize,userId){
    generateBoard(matrixSize)
    user_id=userId
    can_play=true
    timer(time)
  }

  function startConnection() {
    websocket= new WebSocket(wsUri)
    websocket.onopen = function(evt) {

    };
    websocket.onmessage = function(evt) {
      onMessage(evt);
    };
    websocket.onerror = function(evt) {
      onError();
    };
    websocket.onclose = function(evt){
      console.log('Web socket closed')
      endGame();
    };
  }

  startConnection();

  function onMessage(evt) {
    json = JSON.parse(evt.data);
    action = json.action
    if(action=="paintedSpot"){
      paintSpot(json.x,json.y,json.color)
    }else if(action=="startGame"){
      console.log(json)
      setColor(json.color)
      startGame(json.time,json.matrixSize,json.userId)
    }else if(action=='timeIsOver'){
      endGame()
    }
  }
  function onError(evt) {
    alert("An error has occurred")
  }
  function doSend(message) {
    websocket.send(JSON.stringify(message));
    //websocket.close();
  }


  window.addEventListener('touchmove', function(e) {
    // we're not interested in this
    // but prevent default behaviour
    // so the screen doesn't scroll
    // or zoom
    e.preventDefault();
    console.log("touchmove")
    console.log(e)
  }, false);




  var pointHTML = '<div class="point"><div></div></div>'
  var board=$('#board')
  var boardSize = 5;


  function endGame(){
    can_play=false
    determineWinner()
    websocket.close()
  }

  function sendPoint(x,y){
    message={'action':"paintSpot",'x':x,'y':y,'userId':user_id}
    console.log(message)
    doSend(message)
  }

  function paintSpot(x,y,color){
    $($('#board')[0].rows[y].cells[x]).children().children().css('background-color',colors[color]);
    if(colors[color] == self_color){
      $($('#board')[0].rows[y].cells[x]).children().children().data('color',self_color)
    }else{
      $($('#board')[0].rows[y].cells[x]).children().children().data('color',opponent_color)
    }
    console.log($($('#board')[0].rows[y].cells[x]).children().children().data())
  }

  board.on('tap','.point',function(){
    point = $(this);
    if(can_play){
      cell = $(point.parents('td')[0]);
      paintSpot(cell.data('x'),cell.data('y'),self_color);
      sendPoint(cell.data('x'),cell.data('y'));
    }else{
      alert("You are not playing");
    }
  });

  function determineWinner(){
    mine=0
    his=0
    $('#board tr').each(function(){
      $('td').each(function(){
        point=$(this).children().children()
        if(point.data('color')== self_color){
          mine+=1
        }else if(point.data('color')== opponent_color){

          his+=1
        }
      })
    });
    if(mine > his) {
      alert('You won!')
    }else if(mine < his){
      alert('You lose!')
    }else{
      alert('Draw!')
    }
  }


  function sendGameOver(){
    message={'action':'timeIsOver'};
    doSend(message);
  }

  function timer(time){
    var counter = time;

    setInterval(function() {
      counter--;
      if (counter >= 0) {
        $('#timer').text(counter);
      }
      if (counter === 0) {
        sendGameOver();
        endGame();
        clearInterval();
      }

    }, 1000);

  }

  // Disable double tap-zoom
  (function($) {
    var count = 0;
    $.fn.nodoubletapzoom = function() {
      $(this).bind('touchstart', function preventZoom(e){
        var t2 = e.timeStamp;
        var t1 = $(this).data('lastTouch') || t2;
        var dt = t2 - t1;
        var fingers = e.originalEvent.touches.length;
        $(this).data('lastTouch', t2);
        if (!dt || dt > 500 || fingers > 1){
          return; // not double-tap
        }
        e.preventDefault(); // double tap - prevent the zoom
        // also synthesize click events we just swallowed up
        $(e.target).trigger('tap');
      });
    };
  })(jQuery);

  $(document).on('pageinit',"body", function() {
    $("body").nodoubletapzoom();
  });


</script>
